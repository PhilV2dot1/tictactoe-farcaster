<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tic Tac Toe - Celo</title>
    
    <!-- Preconnect pour optimiser le chargement -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="dns-prefetch" href="https://forno.celo.org">
    
    <!-- Scripts avec defer pour ne pas bloquer le rendu -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js" defer></script>
    <script src="https://unpkg.com/@farcaster/frame-sdk@0.1.2/dist/index.js" defer></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --primary: #35D07F;
            --primary-dark: #2AB56F;
            --secondary: #FBCC5C;
            --danger: #FF5252;
            --warning: #FFA726;
            --bg-yellow: #FCFF52;
            --text-primary: #1A1A1A;
            --text-secondary: #4A4A4A;
            --shadow: 0 4px 20px rgba(53, 208, 127, 0.3);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #FCFF52 0%, #FFE55C 100%);
            min-height: 100vh;
            color: var(--text-primary);
            overflow-x: hidden;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .app-container {
            max-width: 500px;
            margin: 0 auto;
            padding: 12px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            margin-bottom: 16px;
            animation: fadeInDown 0.5s ease;
        }

        .logo {
            font-size: 2.5em;
            margin-bottom: 4px;
            filter: drop-shadow(0 2px 8px rgba(53, 208, 127, 0.5));
        }

        .title {
            font-size: 1.5em;
            font-weight: 700;
            background: linear-gradient(135deg, #35D07F 0%, #2AB56F 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            margin-bottom: 4px;
        }

        .subtitle {
            font-size: 0.75em;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .mode-toggle {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            background: rgba(255, 255, 255, 0.9);
            padding: 6px;
            border-radius: 16px;
            margin-bottom: 16px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
        }

        .mode-btn {
            padding: 12px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #35D07F 0%, #2AB56F 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(53, 208, 127, 0.3);
            transform: translateY(-2px);
        }

        .wallet-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 16px;
            display: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .wallet-card.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .wallet-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .wallet-info {
            flex: 1;
            min-width: 0;
        }

        .wallet-label {
            font-size: 0.75em;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .wallet-address {
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: var(--text-primary);
            background: rgba(53, 208, 127, 0.15);
            padding: 6px 10px;
            border-radius: 8px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: var(--shadow);
            white-space: nowrap;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-primary {
            background: linear-gradient(135deg, #35D07F 0%, #2AB56F 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #FF5252 0%, #e04545 100%);
            color: white;
        }

        .game-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
        }

        .status-banner {
            background: linear-gradient(135deg, rgba(53, 208, 127, 0.2) 0%, rgba(42, 181, 111, 0.2) 100%);
            border-left: 4px solid #35D07F;
            padding: 12px 16px;
            border-radius: 12px;
            margin-bottom: 20px;
            font-size: 0.95em;
            font-weight: 600;
            text-align: center;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
        }

        .status-banner.win {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.2) 0%, rgba(69, 160, 73, 0.2) 100%);
            border-left-color: #4CAF50;
        }

        .status-banner.lose {
            background: linear-gradient(135deg, rgba(255, 82, 82, 0.2) 0%, rgba(224, 69, 69, 0.2) 100%);
            border-left-color: #FF5252;
        }

        .status-banner.draw {
            background: linear-gradient(135deg, rgba(255, 167, 38, 0.2) 0%, rgba(255, 152, 0, 0.2) 100%);
            border-left-color: #FFA726;
        }

        .board-container {
            aspect-ratio: 1;
            max-width: 380px;
            margin: 0 auto 20px;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 100%;
            height: 100%;
        }

        .cell {
            aspect-ratio: 1;
            background: linear-gradient(135deg, #FFFFFF 0%, #F5F5F5 100%);
            border: 3px solid rgba(53, 208, 127, 0.3);
            border-radius: 16px;
            font-size: clamp(2.5em, 8vw, 3.5em);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            user-select: none;
        }

        .cell:hover:not(.filled) {
            background: linear-gradient(135deg, rgba(53, 208, 127, 0.1) 0%, rgba(42, 181, 111, 0.05) 100%);
            transform: scale(1.05);
        }

        .cell:active:not(.filled) {
            transform: scale(0.95);
        }

        .cell.filled {
            cursor: not-allowed;
            border-color: rgba(53, 208, 127, 0.6);
        }

        .cell.x {
            color: #35D07F;
            text-shadow: 0 0 20px rgba(53, 208, 127, 0.5);
            animation: placeX 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .cell.o {
            color: #FBCC5C;
            text-shadow: 0 0 20px rgba(251, 204, 92, 0.5);
            animation: placeO 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .game-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 16px;
        }

        .game-controls .btn {
            flex: 1;
            padding: 14px;
            font-size: 1em;
        }

        .stats-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .stats-header {
            font-size: 1.1em;
            font-weight: 700;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-primary);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .stat-card {
            background: linear-gradient(135deg, #F8F8F8 0%, #FFFFFF 100%);
            border-radius: 12px;
            padding: 12px;
            text-align: center;
            border: 2px solid rgba(53, 208, 127, 0.2);
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: 700;
            color: #35D07F;
            line-height: 1;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 0.7em;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .leaderboard {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .leaderboard-scroll {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 12px;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: linear-gradient(135deg, #F8F8F8 0%, #FFFFFF 100%);
            border-radius: 12px;
            margin-bottom: 8px;
            border: 2px solid rgba(53, 208, 127, 0.2);
        }

        .leaderboard-rank {
            font-size: 1.2em;
            font-weight: 700;
            color: #35D07F;
            min-width: 30px;
        }

        .leaderboard-rank.top3 {
            font-size: 1.5em;
        }

        .leaderboard-info {
            flex: 1;
            min-width: 0;
        }

        .leaderboard-address {
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: 600;
        }

        .leaderboard-stats {
            font-size: 0.75em;
            color: var(--text-secondary);
            margin-top: 2px;
            font-weight: 500;
        }

        .leaderboard-wins {
            font-size: 1.2em;
            font-weight: 700;
            color: #FBCC5C;
            min-width: 50px;
            text-align: right;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .spinner {
            border: 3px solid rgba(53, 208, 127, 0.2);
            border-top: 3px solid #35D07F;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes placeX {
            from {
                opacity: 0;
                transform: scale(0) rotate(-180deg);
            }
            to {
                opacity: 1;
                transform: scale(1) rotate(0);
            }
        }

        @keyframes placeO {
            from {
                opacity: 0;
                transform: scale(0) rotate(180deg);
            }
            to {
                opacity: 1;
                transform: scale(1) rotate(0);
            }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 400px) {
            .app-container {
                padding: 8px;
            }
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <div class="logo">üéÆ</div>
            <h1 class="title">Tic Tac Toe</h1>
            <p class="subtitle">Powered by Celo</p>
        </div>

        <div class="mode-toggle">
            <button class="mode-btn active" onclick="switchMode('free')">
                <span>üéØ</span>
                <span>Free Play</span>
            </button>
            <button class="mode-btn" onclick="switchMode('chain')">
                <span>‚õìÔ∏è</span>
                <span>On-Chain</span>
            </button>
        </div>

        <div class="wallet-card" id="walletCard">
            <div class="wallet-status">
                <div class="wallet-info">
                    <div class="wallet-label" id="walletLabel">Not connected</div>
                    <div class="wallet-address" id="walletAddress" style="display:none;"></div>
                </div>
                <button class="btn btn-primary" id="connectBtn" style="display:none;">
                    Connecting...
                </button>
            </div>
        </div>

        <div class="game-card">
            <div class="status-banner" id="statusBanner">
                Click Start to begin! üöÄ
            </div>

            <div class="board-container">
                <div class="game-board" id="gameBoard">
                    <div class="cell" onclick="makeMove(0)"></div>
                    <div class="cell" onclick="makeMove(1)"></div>
                    <div class="cell" onclick="makeMove(2)"></div>
                    <div class="cell" onclick="makeMove(3)"></div>
                    <div class="cell" onclick="makeMove(4)"></div>
                    <div class="cell" onclick="makeMove(5)"></div>
                    <div class="cell" onclick="makeMove(6)"></div>
                    <div class="cell" onclick="makeMove(7)"></div>
                    <div class="cell" onclick="makeMove(8)"></div>
                </div>
            </div>

            <div class="game-controls">
                <button class="btn btn-success" id="startBtn" onclick="startGame()">
                    Start Game
                </button>
                <button class="btn btn-danger" id="resetBtn" onclick="resetGame()" disabled>
                    Reset
                </button>
            </div>
        </div>

        <div class="stats-section">
            <div class="stats-header">
                <span>üìä</span>
                <span>Your Stats</span>
            </div>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="statGames">0</div>
                    <div class="stat-label">Games</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statWins">0</div>
                    <div class="stat-label">Wins</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statLosses">0</div>
                    <div class="stat-label">Losses</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statDraws">0</div>
                    <div class="stat-label">Draws</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statWinRate">0%</div>
                    <div class="stat-label">Win Rate</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statStreak">0</div>
                    <div class="stat-label">Streak</div>
                </div>
            </div>
        </div>

        <div class="leaderboard" id="leaderboard" style="display:none;">
            <div class="stats-header">
                <span>üèÜ</span>
                <span>Leaderboard</span>
            </div>
            <div class="leaderboard-scroll" id="leaderboardContent">
                <div class="loading">
                    <div class="spinner"></div>
                    Loading...
                </div>
            </div>
        </div>
    </div>

    <script>
        // Init Farcaster SDK imm√©diatement
        (async function() {
            if (typeof window.fc !== 'undefined' && window.fc.FrameSDK) {
                try {
                    await window.fc.FrameSDK.actions.ready();
                    console.log('‚úÖ Farcaster Frame SDK ready');
                } catch (e) {
                    console.log('Farcaster SDK init:', e);
                }
            }
        })();

        const CONTRACT_ADDRESS = "0xD92BcD223Aa2A9818CbeB853b1d2beAa9eaf3008";
        const CELO_MAINNET_CHAIN_ID = "0xa4ec";
        const CELO_RPC_URL = "https://forno.celo.org";

        const CONTRACT_ABI = [
            "function startGame() external",
            "function makeMove(uint8 position) external",
            "function forfeitGame() external",
            "function getBoard(address player) external view returns (uint8[9])",
            "function getPlayerStats(address player) external view returns (uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)",
            "function getLeaderboard() external view returns (tuple(address player, uint256 wins, uint256 winRate, uint256 bestStreak, uint256 fastestWin)[])",
            "function activeGames(address) external view returns (address player, uint8[9] board, uint8 currentTurn, uint8 status, uint256 startTime, uint256 endTime, uint8 moveCount)",
            "event GameStarted(address indexed player, uint256 timestamp)",
            "event MoveMade(address indexed player, uint8 position, uint8 playerType)",
            "event GameEnded(address indexed player, uint8 status, uint256 duration)"
        ];

        let currentMode = 'free';
        let gameActive = false;
        let board = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        let currentTurn = 1;
        
        // √âtat de connexion PERSISTANT
        let walletConnected = false;
        let provider = null;
        let signer = null;
        let contract = null;
        let userAddress = null;
        let isProcessing = false;

        let localStats = {
            gamesPlayed: 0,
            wins: 0,
            losses: 0,
            draws: 0,
            currentStreak: 0
        };

        // Attendre le chargement d'ethers
        function waitForEthers(callback, attempts = 0) {
            if (typeof ethers !== 'undefined') {
                callback();
            } else if (attempts < 20) {
                setTimeout(() => waitForEthers(callback, attempts + 1), 100);
            } else {
                console.error('Ethers.js failed to load');
                showMessage('Error loading libraries. Please refresh üîÑ', 'lose');
            }
        }

        function init() {
            waitForEthers(() => {
                console.log('‚úÖ Ethers loaded:', ethers.version);
                loadLocalStats();
                updateStatsDisplay();
                showMessage('Ready to play! üéÆ');
            });
        }

        // CONNEXION UNIQUE au switch vers On-Chain
        async function switchMode(mode) {
            if (isProcessing) return;
            
            currentMode = mode;
            
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.closest('.mode-btn').classList.add('active');

            const walletCard = document.getElementById('walletCard');
            const leaderboard = document.getElementById('leaderboard');
            
            if (mode === 'chain') {
                walletCard.classList.add('active');
                leaderboard.style.display = 'block';
                
                // CONNEXION AUTOMATIQUE si pas encore connect√©
                if (!walletConnected) {
                    await connectWalletOnce();
                } else {
                    await loadOnChainStats();
                    await loadLeaderboard();
                }
            } else {
                walletCard.classList.remove('active');
                leaderboard.style.display = 'none';
                updateStatsDisplay();
            }

            resetGame();
        }

        // CONNEXION UNE SEULE FOIS
        async function connectWalletOnce() {
            if (walletConnected || isProcessing) return;
            isProcessing = true;
            
            const connectBtn = document.getElementById('connectBtn');
            connectBtn.style.display = 'block';
            connectBtn.disabled = true;
            
            try {
                if (!window.ethereum) {
                    showMessage('Please install MetaMask or use Farcaster! ü¶ä', 'lose');
                    connectBtn.textContent = 'No Wallet';
                    return;
                }

                showMessage('Connecting wallet... üîó');
                connectBtn.textContent = 'Connecting...';

                const accounts = await window.ethereum.request({
                    method: 'eth_requestAccounts'
                });

                if (!accounts || accounts.length === 0) {
                    throw new Error('No accounts found');
                }

                userAddress = accounts[0];
                console.log('‚úÖ Connected:', userAddress);

                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();

                // V√©rifier/switcher vers Celo
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                if (chainId !== CELO_MAINNET_CHAIN_ID) {
                    showMessage('Switching to Celo... üîÑ');
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: CELO_MAINNET_CHAIN_ID }]
                        });
                    } catch (switchError) {
                        if (switchError.code === 4902 || switchError.code === -32603) {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: CELO_MAINNET_CHAIN_ID,
                                    chainName: 'Celo Mainnet',
                                    nativeCurrency: { name: 'CELO', symbol: 'CELO', decimals: 18 },
                                    rpcUrls: [CELO_RPC_URL],
                                    blockExplorerUrls: ['https://explorer.celo.org']
                                }]
                            });
                        } else {
                            throw switchError;
                        }
                    }
                }

                // Cr√©er le contrat UNE SEULE FOIS
                contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                console.log('‚úÖ Contract ready');

                // √âcouter les events du contrat
                contract.on("GameEnded", (player, status, duration) => {
                    if (player.toLowerCase() === userAddress.toLowerCase()) {
                        console.log('üéÆ Game ended event:', status.toString());
                        setTimeout(() => {
                            loadOnChainStats();
                            loadLeaderboard();
                        }, 2000);
                    }
                });

                walletConnected = true;

                document.getElementById('walletLabel').textContent = 'Connected ‚úì';
                document.getElementById('walletAddress').textContent = 
                    userAddress.substring(0, 8) + '...' + userAddress.substring(36);
                document.getElementById('walletAddress').style.display = 'block';
                connectBtn.style.display = 'none';

                await loadOnChainStats();
                await loadLeaderboard();

                showMessage('Connected! Ready to play üéâ', 'win');

            } catch (error) {
                console.error('Connection error:', error);
                showMessage('Connection failed: ' + (error.message || 'Unknown error'), 'lose');
                connectBtn.textContent = 'Retry';
                connectBtn.disabled = false;
                connectBtn.onclick = connectWalletOnce;
            } finally {
                isProcessing = false;
            }
        }

        // START GAME - Utilise la connexion existante
        async function startGame() {
            if (isProcessing) return;
            
            if (currentMode === 'chain' && !walletConnected) {
                showMessage('Please wait, connecting...‚è≥', 'lose');
                return;
            }

            isProcessing = true;
            
            try {
                if (currentMode === 'chain') {
                    // V√©rifier s'il y a d√©j√† une partie active
                    try {
                        const activeGame = await contract.activeGames(userAddress);
                        if (activeGame.status === 0) { // GameStatus.Active = 0
                            showMessage('You have an active game! Click Reset first üîÑ', 'lose');
                            isProcessing = false;
                            
                            // Charger le plateau existant
                            const contractBoard = await contract.getBoard(userAddress);
                            board = contractBoard.map(n => n.toNumber());
                            updateBoardDisplay();
                            gameActive = true;
                            document.getElementById('startBtn').disabled = true;
                            document.getElementById('resetBtn').disabled = false;
                            return;
                        }
                    } catch (checkError) {
                        console.log('No active game found, starting new one');
                    }
                    
                    showMessage('Starting on-chain game... ‚è≥');
                    const tx = await contract.startGame();
                    showMessage('Waiting for confirmation... ‚è≥');
                    await tx.wait();
                    console.log('‚úÖ Game started on-chain');
                }

                gameActive = true;
                board = [0, 0, 0, 0, 0, 0, 0, 0, 0];
                currentTurn = 1;
                
                updateBoardDisplay();
                document.getElementById('startBtn').disabled = true;
                document.getElementById('resetBtn').disabled = false;
                showMessage('Your turn! Tap a cell üëÜ');
            } catch (error) {
                console.error('Start error:', error);
                const errorMsg = error.reason || error.message || 'Unknown error';
                showMessage('Failed to start: ' + errorMsg + ' üòû', 'lose');
            } finally {
                isProcessing = false;
            }
        }

        // MAKE MOVE - Utilise la connexion existante
        async function makeMove(position) {
            if (!gameActive || currentTurn !== 1 || board[position] !== 0 || isProcessing) {
                return;
            }

            isProcessing = true;
            
            try {
                if (currentMode === 'chain') {
                    showMessage('Making your move... ‚è≥');
                    
                    // Une seule transaction - l'IA joue automatiquement on-chain
                    const tx = await contract.makeMove(position);
                    showMessage('Waiting for AI response... ü§ñ');
                    await tx.wait();
                    
                    // R√©cup√©rer le plateau mis √† jour
                    const contractBoard = await contract.getBoard(userAddress);
                    board = contractBoard.map(n => n.toNumber());
                    updateBoardDisplay();
                    
                    // V√©rifier si le jeu est termin√©
                    if (checkWin(1)) {
                        showMessage('üéâ You Win!', 'win');
                        gameActive = false;
                        document.getElementById('startBtn').disabled = false;
                    } else if (checkWin(2)) {
                        showMessage('üò¢ AI Wins!', 'lose');
                        gameActive = false;
                        document.getElementById('startBtn').disabled = false;
                    } else if (board.every(cell => cell !== 0)) {
                        showMessage('ü§ù Draw!', 'draw');
                        gameActive = false;
                        document.getElementById('startBtn').disabled = false;
                    } else {
                        showMessage('Your turn! üëÜ');
                    }
                } else {
                    // Free play
                    board[position] = 1;
                    updateBoardDisplay();

                    if (checkWin(1)) {
                        endGame('win');
                        isProcessing = false;
                        return;
                    }

                    if (board.every(cell => cell !== 0)) {
                        endGame('draw');
                        isProcessing = false;
                        return;
                    }

                    currentTurn = 2;
                    showMessage('AI thinking... ü§î');
                    
                    setTimeout(() => {
                        makeAIMove();
                        isProcessing = false;
                    }, 600);
                    return;
                }
            } catch (error) {
                console.error('Move error:', error);
                showMessage('Move failed: ' + (error.message || 'Unknown'), 'lose');
            } finally {
                if (currentMode === 'chain') {
                    isProcessing = false;
                }
            }
        }

        function makeAIMove() {
            let move = findWinningMove(2);
            if (move === -1) move = findWinningMove(1);
            if (move === -1 && board[4] === 0) move = 4;
            if (move === -1) {
                const corners = [0, 2, 6, 8];
                for (let corner of corners) {
                    if (board[corner] === 0) {
                        move = corner;
                        break;
                    }
                }
            }
            if (move === -1) {
                for (let i = 0; i < 9; i++) {
                    if (board[i] === 0) {
                        move = i;
                        break;
                    }
                }
            }

            board[move] = 2;
            updateBoardDisplay();

            if (checkWin(2)) {
                endGame('lose');
                return;
            }

            if (board.every(cell => cell !== 0)) {
                endGame('draw');
                return;
            }

            currentTurn = 1;
            showMessage('Your turn! üëÜ');
        }

        function findWinningMove(player) {
            for (let i = 0; i < 9; i++) {
                if (board[i] === 0) {
                    board[i] = player;
                    if (checkWin(player)) {
                        board[i] = 0;
                        return i;
                    }
                    board[i] = 0;
                }
            }
            return -1;
        }

        function checkWin(player) {
            const lines = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6]
            ];
            return lines.some(line => line.every(index => board[index] === player));
        }

        function endGame(result) {
            gameActive = false;
            
            if (currentMode === 'free') {
                localStats.gamesPlayed++;
                
                if (result === 'win') {
                    localStats.wins++;
                    localStats.currentStreak++;
                    showMessage('üéâ Victory! You Win!', 'win');
                } else if (result === 'lose') {
                    localStats.losses++;
                    localStats.currentStreak = 0;
                    showMessage('üò¢ AI Wins! Try Again', 'lose');
                } else {
                    localStats.draws++;
                    showMessage('ü§ù Draw! Well Played', 'draw');
                }
                
                saveLocalStats();
                updateStatsDisplay();
            }

            document.getElementById('startBtn').disabled = false;
            document.getElementById('resetBtn').disabled = false;
        }

        function resetGame() {
            if (isProcessing) return;
            
            // Si on-chain et partie active, proposer d'abandonner
            if (currentMode === 'chain' && gameActive && walletConnected) {
                if (confirm('Abandon this on-chain game? This will count as a loss.')) {
                    forfeitOnChainGame();
                }
                return;
            }
            
            gameActive = false;
            board = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            currentTurn = 1;
            updateBoardDisplay();
            document.getElementById('startBtn').disabled = false;
            document.getElementById('resetBtn').disabled = true;
            showMessage('Click Start to begin! üöÄ');
        }

        async function forfeitOnChainGame() {
            if (isProcessing) return;
            isProcessing = true;

            try {
                showMessage('Abandoning game... üè≥Ô∏è');
                const tx = await contract.forfeitGame();
                await tx.wait();
                
                gameActive = false;
                board = [0, 0, 0, 0, 0, 0, 0, 0, 0];
                updateBoardDisplay();
                document.getElementById('startBtn').disabled = false;
                document.getElementById('resetBtn').disabled = true;
                
                showMessage('Game abandoned. Ready for a new game! üÜï');
                
                // Rafra√Æchir les stats
                await loadOnChainStats();
                await loadLeaderboard();
            } catch (error) {
                console.error('Forfeit error:', error);
                showMessage('Failed to abandon: ' + (error.message || 'Unknown'), 'lose');
            } finally {
                isProcessing = false;
            }
        }

        function updateBoardDisplay() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach((cell, index) => {
                cell.classList.remove('filled', 'x', 'o');
                if (board[index] === 1) {
                    cell.textContent = 'X';
                    cell.classList.add('filled', 'x');
                } else if (board[index] === 2) {
                    cell.textContent = 'O';
                    cell.classList.add('filled', 'o');
                } else {
                    cell.textContent = '';
                }
            });
        }

        function showMessage(message, type = '') {
            const banner = document.getElementById('statusBanner');
            banner.textContent = message;
            banner.className = 'status-banner ' + type;
        }

        async function loadOnChainStats() {
            if (!contract || !userAddress) return;

            try {
                const stats = await contract.getPlayerStats(userAddress);
                
                document.getElementById('statGames').textContent = stats[0].toString();
                document.getElementById('statWins').textContent = stats[1].toString();
                document.getElementById('statLosses').textContent = stats[2].toString();
                document.getElementById('statDraws').textContent = stats[3].toString();
                document.getElementById('statWinRate').textContent = 
                    (stats[4].toNumber() / 100).toFixed(1) + '%';
                document.getElementById('statStreak').textContent = stats[5].toString();
            } catch (error) {
                console.error('Load stats error:', error);
            }
        }

        async function loadLeaderboard() {
            if (!contract) return;

            const content = document.getElementById('leaderboardContent');
            content.innerHTML = '<div class="loading"><div class="spinner"></div>Loading...</div>';

            try {
                const leaderboard = await contract.getLeaderboard();

                if (leaderboard.length === 0) {
                    content.innerHTML = '<div class="loading">No players yet! üéÆ<br>Be the first!</div>';
                    return;
                }

                let html = '';
                const medals = ['ü•á', 'ü•à', 'ü•â'];
                
                leaderboard.slice(0, 10).forEach((entry, index) => {
                    const addr = entry.player.substring(0, 6) + '...' + entry.player.substring(38);
                    const winRate = (entry.winRate.toNumber() / 100).toFixed(1) + '%';
                    const rankClass = index < 3 ? 'top3' : '';
                    const medal = index < 3 ? medals[index] : `#${index + 1}`;
                    
                    html += `
                        <div class="leaderboard-item">
                            <div class="leaderboard-rank ${rankClass}">${medal}</div>
                            <div class="leaderboard-info">
                                <div class="leaderboard-address">${addr}</div>
                                <div class="leaderboard-stats">${winRate} WR ¬∑ üî• ${entry.bestStreak}</div>
                            </div>
                            <div class="leaderboard-wins">${entry.wins} üèÜ</div>
                        </div>
                    `;
                });

                content.innerHTML = html;
            } catch (error) {
                console.error('Load leaderboard error:', error);
                content.innerHTML = '<div class="loading">Failed to load üòû</div>';
            }
        }

        function loadLocalStats() {
            const saved = localStorage.getItem('tictactoe_stats');
            if (saved) {
                localStats = JSON.parse(saved);
            }
        }

        function saveLocalStats() {
            localStorage.setItem('tictactoe_stats', JSON.stringify(localStats));
        }

        function updateStatsDisplay() {
            if (currentMode === 'free') {
                document.getElementById('statGames').textContent = localStats.gamesPlayed;
                document.getElementById('statWins').textContent = localStats.wins;
                document.getElementById('statLosses').textContent = localStats.losses;
                document.getElementById('statDraws').textContent = localStats.draws;
                
                const winRate = localStats.gamesPlayed > 0 
                    ? ((localStats.wins / localStats.gamesPlayed) * 100).toFixed(1)
                    : 0;
                document.getElementById('statWinRate').textContent = winRate + '%';
                document.getElementById('statStreak').textContent = localStats.currentStreak;
            }
        }

        // Event listeners
        window.addEventListener('load', init);

        if (window.ethereum) {
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length === 0) {
                    walletConnected = false;
                    userAddress = null;
                    provider = null;
                    signer = null;
                    contract = null;
                    document.getElementById('walletLabel').textContent = 'Not connected';
                    document.getElementById('walletAddress').style.display = 'none';
                    document.getElementById('connectBtn').style.display = 'block';
                    document.getElementById('connectBtn').disabled = false;
                    document.getElementById('connectBtn').textContent = 'Connect';
                    resetGame();
                } else if (accounts[0] !== userAddress) {
                    location.reload();
                }
            });

            window.ethereum.on('chainChanged', () => {
                location.reload();
            });
        }
    </script>
</body>
</html>